-- 178. 分数排名

    -- 解法1：分数分类，找出分数大于自己的，然后排序
SELECT score,
(SELECT COUNT(DISTINCT score) FROM Scores where score>=A.score) AS `Rank`
FROM Scores A
ORDER BY Score DESC
    -- 解法2：调用数据库函数
SELECT SCORE,DENSE_RANK()OVER(ORDER BY SCORE DESC) `RANK`
FROM SCORES

-- 180. 连续出现的数字
    -- 方法1：直接解法
SELECT DISTINCT A.NUM AS CONSECUTIVENUMS FROM LOGS A,LOGS B,LOGS C
WHERE A.NUM=B.NUM AND B.NUM=C.NUM AND A.ID=B.ID-1 AND B.ID=C.ID-1

    -- 方法2：使用偏移函数，效率不高不建议使用
SELECT DISTINCT NUM AS CONSECUTIVENUMS  FROM
(
    SELECT NUM,LEAD(NUM,1)OVER()AS NUM1,LEAD(NUM,2)OVER()AS NUM2 
    FROM LOGS
) AS C
WHERE C.NUM = C.NUM1 AND C.NUM1 = C.NUM2

    -- 方法3：模型化，扩大适用范围，先根据ID排序，后根据num分组排序，然后比较排序结果
SELECT DISTINCT NUM AS CONSECUTIVENUMS FROM 
(
    SELECT NUM,COUNT(*) NUM_COUNT FROM 
        (SELECT 
            ID,
            NUM,
            ROW_NUMBER() OVER (ORDER BY ID)-ROW_NUMBER() OVER (PARTITION BY NUM ORDER BY ID) AS ORDE
         FROM LOGS) AS W
        GROUP BY NUM,ORDE
) AS S WHERE NUM_COUNT>=3
